#include "maxflow_BK.h"

void err_func3(char * err){
	throw debug_exception(err);
};

maxflow_BK::maxflow_BK(){
	info.name = "BK";
	g = 0;
};

/*depricated//
void maxflow_BK::construct(const dynamic::num_array<int,2>  & E, dynamic::num_array<int,2> & cap, dynamic::num_array<int,1> & excess){
	using namespace exttype;
	info.construct_t.resume();
	int nV = excess.size();
	int nE = E.size()[1];
	g = new tgraph(nV,nE,&err_func3);
	g->add_node(nV);
	for(int e=0;e<nE;++e){
		int u = E[mint2(0,e)];
		int v = E[mint2(1,e)];
		g->add_edge(u, v, cap[mint2(0,e)], cap[mint2(1,e)]);
	};
	for(int u=0;u<nV;++u){
		g->add_tweights(u,excess[u],0);
	};
	info.construct_t.pause();
};
*/

void maxflow_BK::construct(const char * filename){
	info.construct_t.resume();
	dimacs_parser(filename,*this,2);
	info.construct_t.pause();
};

void maxflow_BK::allocate1(int n ,int m, int S, int T,int d,int * sz){
	this->nV = n;
	this->S = S;
	this->T = T;
	nE=0;
};

void maxflow_BK::allocate2(int loop){
	if(loop==0){
		debug::stream<<"solver: BK\n";
		debug::stream<<"vert: "<<nV<<"\n";
		debug::stream<<"edges: "<<nE<<"\n";
		long long sz = (((long long)(nE))*2*sizeof(tgraph::arc)+((long long)(nV))*sizeof(tgraph::node))/1024/1024;
		debug::stream<<"mem_shared: "<<sz<<"Mb\n";
		g = new tgraph(nV,nE,&err_func3);
		g->add_node(nV);
		g->nodes[S].tr_cap = 1;
		g->nodes[T].tr_cap = -1;
		nE=0;
	};
};

void maxflow_BK::read_arc(int loop,int u,int v,int cap1, int cap2){
	if(loop==0){
		if(u==S){//source link
		}else if(v==T){//sink link
		}else{//regular edge
			++nE;
		};
	}else{
		if(u==S){//source link
			g->add_tweights(v,cap1,cap2);
		}else if(v==T){//sink link
			g->add_tweights(u,cap2,cap1);
		}else{//regular edge
			g->add_edge(u, v, cap1, cap2);
			++nE;
		};
	};
};

maxflow_BK::tflow maxflow_BK::maxflow(){
	info.solve_t.start();
	info.augment_t.start();
	info.flow = g->maxflow();
	info.augment_t.stop();
	info.solve_t.stop();
	info.nV = nV;
	info.nE = nE;
	info.mem_shared = dynamic::memserver::get_al_blocks().mem_used();
	return info.flow;
};
maxflow_BK::~maxflow_BK(){
	if(g)delete g;
};

bool maxflow_BK::is_weak_source(int v){
	return g->what_segment(v,tgraph::SOURCE)==tgraph::SOURCE;
};

void maxflow_BK::save_cut(const std::string & filename){
	FILE * f = fopen(filename.c_str(),"wt+");
	setvbuf(f,NULL,_IOFBF,1024*1024*2);
	fprintf(f,"p max %i %i\n",nV,nE);
	fprintf(f,"c minimum cut, generated by %s\n",info.name.c_str());
	fprintf(f,"f %lli\n",info.flow);
	//fprintf(f,"n 1 1\n");//source has label 1
	//fprintf(f,"n 2 0\n");//sink has label 0
	for(int v=0;v<nV;++v){
		fprintf(f,"n %i %i\n",v+1,is_weak_source(v));
	};
};

void maxflow_BK::get_cut(int * C){
	for(int v=0;v<nV;++v){
		C[v] = is_weak_source(v);
	};
};

long long maxflow_BK::cut_cost(int * C){
	long long cost = g->flow;
	for(tgraph::arc * a = g->arcs; a!=g->arc_last;++a){
		tgraph::node * u = a->sister->head;
		tgraph::node * v = a->head;
		if(C[u-g->nodes]==1 && C[v-g->nodes]==0){
			cost+=a->r_cap;
		};
	};
	return cost;
};

long long maxflow_BK::cut_cost(){
	long long cost = g->flow;
	for(tgraph::arc * a = g->arcs; a!=g->arc_last;++a){
		int u = a->sister->head-g->nodes;
		int v = a->head-g->nodes;
		if(is_weak_source(u) && !is_weak_source(v)){
			cost+=a->r_cap;
		};
	};
	return cost;
};