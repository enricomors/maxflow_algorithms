//#include "split-cpp/mextiming.h"

#include "debug/performance.h"
#include <stdio.h>
#include <stdarg.h>

debug::PerformanceCounter c2;

void inline startTime()
{
	c2.start();
};

double inline endTime(const char* format="", ...)
{
	double time = c2.time();
	char buffer[512];
	va_list args;
	va_start( args, format );
	vsnprintf(buffer, 512, format, args);
	va_end( args );
	printf("%s: %f \n", buffer,time);
	c2.start();
	return time;
};

#include "maxflow_dd.h"
#include <stdexcept>

//Error function to maxflow library
void err_func(char* err)
{
	throw std::runtime_error(err);
}


maxflow_dd::maxflow_dd(){
	info.name = "P-DD";
	g = 0;
	nR = 4;
	margin = 0;
};

void maxflow_dd::construct(const char * filename){
	info.construct_t.resume();
	dimacs_parser(filename,*this,2);
	info.construct_t.pause();
};

void maxflow_dd::allocate1(int n ,int m, int S, int T,int d,int * sz){
	this->nV = n;
	this->S = S;
	this->T = T;
	nE=0;
	//slice = 1;
	this->sz.resize(d);
	for(int l=0;l<d;++l){
		this->sz[l] = sz[l];
/*	
		if(l>0){
			slice*=sz[l];
		};
		*/
	};
	split.resize(nR-1);
	assert(nV>nR);
	for(int r=1;r<nR;++r){
		split[r-1] = (nV/nR)*r;
		//split[r-1] = (sz[0]/nR)*r*slice;
		//split[r-1] += 2;// for source and sink
	};
	nnE.resize(nR);
	nnE << 0;
	//margin = product of all dimensions but the first one
};

void maxflow_dd::allocate2(int loop){
	if(loop==0){
		debug::stream<<"solver: DD\n";
		debug::stream<<"vert: "<<nV<<"\n";
		debug::stream<<"edges: "<<nE<<"\n";
		for(int r=0;r<nR;++r){
			nnE[r] += margin * 10;
		};
		//long long sz = (((long long)(nE))*2*sizeof(tgraph::arc)+((long long)(nV))*sizeof(tgraph::node))/1024/1024;
		//debug::stream<<"mem_shared: "<<sz<<"Mb\n";
		g = new tgraph(nR,nV,nE,split.begin(),margin,nnE.begin());
		//g->nodes[S].tr_cap = 1;
		//g->nodes[T].tr_cap = -1;
		nE=0;
	};
};

int maxflow_dd::get_region(int u){
	int r=0;
	for(;r<nR-1 && split[r]< u;++r);
	return r;
};

void maxflow_dd::read_arc(int loop,int u,int v,int cap1, int cap2){
	if(loop==0){
		if(u==S){//source link
		}else if(v==T){//sink link
		}else{//regular edge
			++nE;
			int r = get_region(u);
			int q = get_region(v);
			++nnE[r];
			if(r!=q){//edge across the split
				++nnE[q];
				margin = std::max(margin,abs(u-v));
			};
		};
	}else{
		if(u==S){//source link
			g->add_tweights(v,cap1*2,cap2*2);
		}else if(v==T){//sink link
			g->add_tweights(u,cap2*2,cap1*2);
		}else{//regular edge
			g->add_edge(u, v, cap1*2, cap2*2);
			++nE;
		};
	};
};

maxflow_dd::tflow maxflow_dd::maxflow(){
	debug::stream<<"Regions: "<<nR<<"\n";
	info.solve_t.start();
	info.augment_t.start();
	g->maxflow();
	if(g->is_global==false){
		debug::stream<<"maximum number of iterations performed, no optimal cut\n";
	};
	info.sweeps = g->iter;
	info.flow = g->flow/2;
	info.augment_t.stop();
	info.solve_t.stop();
	info.nV = nV;
	info.nE = nE;
	info.mem_shared = dynamic::memserver::get_al_blocks().mem_used();
	return info.flow;
};
maxflow_dd::~maxflow_dd(){
	if(g)delete g;
};

void maxflow_dd::save_cut(const std::string & filename){
	FILE * f = fopen(filename.c_str(),"wt+");
	setvbuf(f,NULL,_IOFBF,1024*1024*2);
	fprintf(f,"p max %i %i\n",nV,nE);
	fprintf(f,"c minimum cut, generated by %s\n",info.name.c_str());
	fprintf(f,"f %lli\n",info.flow);
	//fprintf(f,"n 1 1\n");//source has label 1
	//fprintf(f,"n 2 0\n");//sink has label 0
	for(int v=0;v<nV;++v){
		if(v==S){
			fprintf(f,"n %i 1\n",S+1);//source has label 1
		}else if(v==T){
			fprintf(f,"n %i 0\n",T+1);//sink has label 0
		}else{
			fprintf(f,"n %i %i\n",v+1,1-g->what_segment(v));
		};
	};
};

long long maxflow_dd::cut_cost(){
	long long cost = info.flow;
	//this is a stumb
	return cost;
};
